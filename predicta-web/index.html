<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PredictAAI - Geli≈ümi≈ü Analiz Motoru</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #ffc107;
            --primary-dark: #ff9800;
            --secondary: #667eea;
            --success: #10b981;
            --danger: #ef4444;
            --dark: #0a0e27;
            --dark-light: #1a1f3a;
            --dark-lighter: #2a2f4a;
            --text: #ffffff;
            --text-muted: rgba(255, 255, 255, 0.6);
            --border: rgba(255, 193, 7, 0.1);
            --glow: rgba(255, 193, 7, 0.3);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--dark);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .animated-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            background: 
                radial-gradient(ellipse at 10% 20%, rgba(102, 126, 234, 0.15) 0%, transparent 50%),
                radial-gradient(ellipse at 90% 80%, rgba(255, 193, 7, 0.1) 0%, transparent 50%);
            animation: bgPulse 20s ease-in-out infinite;
        }

        @keyframes bgPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .main-wrapper {
            position: relative;
            z-index: 1;
        }

        .premium-header {
            background: linear-gradient(135deg, rgba(10, 14, 39, 0.95), rgba(26, 31, 58, 0.95));
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 30px;
            border-bottom: 1px solid var(--border);
        }

        .status-group {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .status-pill {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(26, 31, 58, 0.8);
            border: 1px solid var(--border);
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
        }

        .status-pill.active {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(16, 185, 129, 0.1));
            border-color: var(--success);
            color: var(--success);
        }

        .logo-section {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            padding: 25px 30px;
        }

        .logo-orb {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, var(--secondary), var(--primary-dark));
            border: 3px solid var(--primary);
            box-shadow: 0 0 40px var(--glow);
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        .logo-text h1 {
            font-size: 36px;
            font-weight: 900;
            letter-spacing: 2px;
            background: linear-gradient(135deg, var(--primary), #fff, var(--primary));
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradientShift 3s ease infinite;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .logo-text p {
            font-size: 11px;
            letter-spacing: 4px;
            color: var(--primary);
            font-weight: 600;
            text-transform: uppercase;
            margin-top: 5px;
        }

        .control-panel {
            padding: 20px 30px;
            background: rgba(26, 31, 58, 0.5);
            border-bottom: 1px solid var(--border);
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .premium-btn {
            padding: 14px 28px;
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            border: none;
            border-radius: 12px;
            color: var(--dark);
            font-weight: 700;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.3);
        }

        .premium-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(255, 193, 7, 0.5);
        }

        .premium-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .premium-btn.secondary {
            background: rgba(42, 47, 74, 0.9);
            border: 2px solid rgba(255, 193, 7, 0.3);
            color: var(--primary);
            box-shadow: none;
        }

        .premium-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .premium-match-card {
            background: linear-gradient(135deg, rgba(26, 31, 58, 0.95), rgba(42, 47, 74, 0.95));
            backdrop-filter: blur(20px);
            border: 1px solid var(--border);
            border-left: 4px solid var(--primary);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            transition: all 0.4s ease;
            max-width: 100%;
            overflow: hidden;
        }

        .premium-match-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        }

        .match-header {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 15px;
            margin-bottom: 12px;
        }

        @media (max-width: 768px) {
            .match-header {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            
            .prediction-panel {
                min-width: 100% !important;
            }
        }

        .team-info {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .match-teams {
            font-size: 16px;
            font-weight: 700;
            color: var(--text);
            line-height: 1.3;
        }

        .vs-separator {
            color: var(--primary);
            font-weight: 900;
            margin: 0 8px;
        }

        .match-meta {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .meta-badge {
            padding: 3px 8px;
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.3);
            border-radius: 6px;
            font-size: 10px;
            font-weight: 600;
            color: var(--primary);
        }

        .prediction-panel {
            background: rgba(10, 14, 39, 0.6);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px;
            min-width: 250px;
        }

        .prediction-header {
            font-size: 11px;
            font-weight: 700;
            color: var(--text-muted);
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        .odds-row {
            display: flex;
            gap: 6px;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .odds-label {
            font-size: 10px;
            color: var(--text-muted);
            font-weight: 600;
            min-width: 70px;
        }

        .odds-values {
            display: flex;
            gap: 5px;
            flex: 1;
            justify-content: flex-end;
        }

        .odd-item {
            padding: 5px 10px;
            background: rgba(42, 47, 74, 0.8);
            border: 1px solid rgba(255, 193, 7, 0.2);
            border-radius: 6px;
            font-size: 12px;
            font-weight: 700;
            color: var(--text-muted);
            min-width: 45px;
            text-align: center;
        }

        .odd-item.selected {
            background: var(--primary);
            border-color: var(--primary);
            color: var(--dark);
            box-shadow: 0 0 15px rgba(255, 193, 7, 0.4);
        }

        .confidence-meter {
            background: rgba(10, 14, 39, 0.8);
            border: 2px solid;
            border-radius: 6px;
            padding: 6px 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 8px;
        }

        .confidence-value {
            font-size: 14px;
            font-weight: 900;
        }

        .analysis-section {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border);
        }

        .analysis-title {
            font-size: 12px;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 10px;
        }

        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 8px;
        }

        @media (max-width: 768px) {
            .analysis-grid {
                grid-template-columns: 1fr;
            }
        }

        .analysis-card {
            background: rgba(10, 14, 39, 0.6);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 8px;
        }

        .analysis-card-title {
            font-size: 9px;
            font-weight: 700;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .premium-loading {
            text-align: center;
            padding: 60px 20px;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(255, 193, 7, 0.1);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 16px;
            font-weight: 600;
            color: var(--primary);
        }

        .premium-alert {
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
            border: 2px solid;
        }

        .premium-alert.success {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(5, 150, 105, 0.2));
            border-color: var(--success);
        }

        .premium-alert.warning {
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.2), rgba(255, 152, 0, 0.2));
            border-color: var(--primary);
        }

        .filter-panel {
            padding: 15px 20px;
            background: rgba(26, 31, 58, 0.5);
            border-bottom: 1px solid var(--border);
        }
        
        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .filter-group label {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
        }
        
        .filter-group select {
            padding: 8px 12px;
            background: rgba(42, 47, 74, 0.9);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            min-width: 130px;
        }

        .data-quality {
            margin-top: 5px;
            padding: 4px;
            background: rgba(10, 14, 39, 0.6);
            border-radius: 4px;
            font-size: 8px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="animated-bg"></div>
    
    <div class="main-wrapper">
        <header class="premium-header">
            <div class="header-top">
                <div class="status-group">
                    <div class="status-pill active">
                        <span>üß† Akƒ±llƒ± Analiz Motoru</span>
                    </div>
                    <div class="status-pill">
                        üìä <span id="match-count">0</span> Ma√ß
                    </div>
                    <div class="status-pill">
                        üéØ <span id="prediction-count">0</span> Tahmin
                    </div>
                    <div class="status-pill" id="csv-status">
                        üìÇ CSV: Bekleniyor
                    </div>
                    <div class="status-pill" id="api-status">
                        üåê API: Kontrol Ediliyor
                    </div>
                </div>
            </div>
            
            <div class="logo-section">
                <div class="logo-orb"></div>
                <div class="logo-text">
                    <h1>PREDICTAAI</h1>
                    <p>Advanced AI Engine</p>
                </div>
            </div>
            
            <div class="control-panel">
                <button class="premium-btn secondary" onclick="manualLoadCSV()">
                    üìÇ Manuel CSV Y√ºkle
                </button>
                <button class="premium-btn" onclick="wakeUpAPI()" id="wake-api-btn">
                    üî• API'yi Uyandƒ±r
                </button>
                <button class="premium-btn" onclick="fetchMatches()" id="fetch-matches-btn">
                    üìä Ma√ßlarƒ± Y√ºkle
                </button>
                <button class="premium-btn" id="predict-all-btn" onclick="predictAllMatches()" disabled>
                    üéØ Geli≈ümi≈ü Analiz Yap
                </button>
                <button class="premium-btn secondary" onclick="loadManualMatches()">
                    üß™ Manuel Ma√ß Ekle
                </button>
                <button class="premium-btn secondary" onclick="clearAll()">
                    üóëÔ∏è Temizle
                </button>
            </div>
            
            <div class="filter-panel" id="filter-panel" style="display: none;">
                <div style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap;">
                    <div class="filter-group">
                        <label>üìÖ G√ºn:</label>
                        <select id="filter-date" onchange="applyFilters()">
                            <option value="all">T√ºm√º</option>
                            <option value="today">Bug√ºn</option>
                            <option value="tomorrow">Yarƒ±n</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label>üéØ Min. G√ºven:</label>
                        <select id="filter-confidence" onchange="applyFilters()">
                            <option value="0">T√ºm√º</option>
                            <option value="50">%50+</option>
                            <option value="60">%60+</option>
                            <option value="70">%70+</option>
                            <option value="80">%80+</option>
                        </select>
                    </div>
                    
                    <div class="filter-group">
                        <label>üìä Sƒ±ralama:</label>
                        <select id="filter-sort" onchange="applyFilters()">
                            <option value="default">Varsayƒ±lan</option>
                            <option value="confidence-desc">G√ºven (Y√ºksek ‚Üí D√º≈ü√ºk)</option>
                            <option value="confidence-asc">G√ºven (D√º≈ü√ºk ‚Üí Y√ºksek)</option>
                            <option value="date-asc">Tarih (Erken ‚Üí Ge√ß)</option>
                            <option value="quality-desc">Veri Kalitesi (Y√ºksek ‚Üí D√º≈ü√ºk)</option>
                        </select>
                    </div>
                    
                    <button class="premium-btn secondary" onclick="resetFilters()" style="padding: 8px 16px; margin-left: auto;">
                        üîÑ Sƒ±fƒ±rla
                    </button>
                </div>
            </div>
        </header>

        <div class="premium-container" id="match-container">
            <div class="premium-loading">
                <div class="loading-spinner"></div>
                <div class="loading-text">Hazƒ±rlanƒ±yor...</div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE_URL = 'https://predicta-web.onrender.com';
        
        // NESƒ∞NE BAHƒ∞S Tƒ∞Pƒ∞ KODLARI
        const NESINE_BET_TYPES = {
            1: 'MS', // Ma√ß Sonucu (1, X, 2)
            450: 'Over/Under 2.5', // Alt/√úst 2.5
            38: 'BTTS', // Kar≈üƒ±lƒ±klƒ± Gol (Both Teams To Score)
            3: 'Handikap',
            7: 'ƒ∞lk Yarƒ±/Ma√ß Sonucu',
            13: 'Toplam Gol 1.5',
            14: 'Toplam Gol 3.5',
            // Diƒüer bet type'lar eklenebilir
        };
        
        let allMatches = [];
        let predictions = {};
        let historicalData = null;
        let teamStats = {};
        let apiStatus = 'checking';

        // ‚úÖ YENƒ∞: NESƒ∞NE ORAN √áEKME FONKSƒ∞YONU
        function extractOddsFromNesine(match) {
            console.log('üîç Nesine oran √ßƒ±karma ba≈üladƒ±...');
            
            // Varsayƒ±lan deƒüerler
            const defaultOdds = {
                '1': 2.0,
                'X': 3.2,
                '2': 3.5,
                'Over/Under +2.5': { 'Over +2.5': 1.9, 'Under +2.5': 1.9 },
                'Both Teams To Score': { 'Yes': 1.85, 'No': 1.95 }
            };
            
            // Eƒüer oranlar yoksa veya oranlar array deƒüilse varsayƒ±lan d√∂n
            if (!match.oranlar || !Array.isArray(match.oranlar)) {
                console.warn('‚ö†Ô∏è Oranlar bulunamadƒ±, varsayƒ±lan deƒüerler kullanƒ±lƒ±yor');
                return defaultOdds;
            }
            
            const result = { ...defaultOdds };
            
            // Oranlar array'ini d√∂ng√ºyle i≈üle
            match.oranlar.forEach(betGroup => {
                const betType = betGroup.bahis_tipi;
                const odds = betGroup.oranlar;
                
                // Ma√ß Sonucu (1, X, 2)
                if (betType === 1 && Array.isArray(odds) && odds.length >= 3) {
                    result['1'] = parseFloat(odds[0].O) || 2.0;
                    result['X'] = parseFloat(odds[1].O) || 3.2;
                    result['2'] = parseFloat(odds[2].O) || 3.5;
                    console.log('‚úÖ Ma√ß Sonucu oranlarƒ± bulundu:', result['1'], result['X'], result['2']);
                }
                
                // Alt/√úst 2.5 Gol
                if (betType === 450 && Array.isArray(odds) && odds.length >= 2) {
                    result['Over/Under +2.5'] = {
                        'Over +2.5': parseFloat(odds[0].O) || 1.9,
                        'Under +2.5': parseFloat(odds[1].O) || 1.9
                    };
                    console.log('‚úÖ Alt/√úst 2.5 oranlarƒ± bulundu:', result['Over/Under +2.5']);
                }
                
                // Kar≈üƒ±lƒ±klƒ± Gol (BTTS)
                if (betType === 38 && Array.isArray(odds) && odds.length >= 2) {
                    result['Both Teams To Score'] = {
                        'Yes': parseFloat(odds[0].O) || 1.85,
                        'No': parseFloat(odds[1].O) || 1.95
                    };
                    console.log('‚úÖ BTTS oranlarƒ± bulundu:', result['Both Teams To Score']);
                }
            });
            
            console.log('üìä √áƒ±karƒ±lan t√ºm oranlar:', result);
            return result;
        }

        // ‚úÖ YENƒ∞: STANDART ORAN √áEKME FONKSƒ∞YONU (Diƒüer API'ler i√ßin)
        function extractOddsStandard(match) {
            const odds = match.odds || {};
            
            const baseOdds = {
                '1': parseFloat(odds['1'] || odds.home_win || odds.home || 2.0),
                'X': parseFloat(odds['X'] || odds.draw || 3.2),
                '2': parseFloat(odds['2'] || odds.away_win || odds.away || 3.5)
            };
            
            let overUnderOdds = {
                'Over +2.5': 1.9,
                'Under +2.5': 1.9
            };
            
            let overUnderSource = 'hesaplandƒ±';
            
            // T√ºm olasƒ± formatlarƒ± kontrol et
            if (odds['Over/Under +2.5'] && typeof odds['Over/Under +2.5'] === 'object') {
                overUnderOdds = {
                    'Over +2.5': parseFloat(odds['Over/Under +2.5']['Over +2.5'] || odds['Over/Under +2.5'].over || 1.9),
                    'Under +2.5': parseFloat(odds['Over/Under +2.5']['Under +2.5'] || odds['Over/Under +2.5'].under || 1.9)
                };
                overUnderSource = 'API';
            } else if (odds.over_under) {
                overUnderOdds = {
                    'Over +2.5': parseFloat(odds.over_under.over || 1.9),
                    'Under +2.5': parseFloat(odds.over_under.under || 1.9)
                };
                overUnderSource = 'API';
            } else if (odds.over_25 || odds.under_25) {
                overUnderOdds = {
                    'Over +2.5': parseFloat(odds.over_25 || 1.9),
                    'Under +2.5': parseFloat(odds.under_25 || 1.9)
                };
                overUnderSource = 'API';
            } else {
                // Eƒüer yoksa ma√ß sonucu oranlarƒ±ndan tahmin et
                const homeOdds = baseOdds['1'];
                const drawOdds = baseOdds['X'];
                const awayOdds = baseOdds['2'];
                
                // Favorinin oranƒ± d√º≈ü√ºkse, gol ihtimali y√ºksek
                const minOdds = Math.min(homeOdds, awayOdds);
                
                if (minOdds < 1.5) {
                    // √áok net favori var - √ºst tahmini
                    overUnderOdds = {
                        'Over +2.5': 1.70,
                        'Under +2.5': 2.10
                    };
                } else if (minOdds > 2.5) {
                    // Dengeli ma√ß - gol ihtimali normal
                    overUnderOdds = {
                        'Over +2.5': 1.90,
                        'Under +2.5': 1.90
                    };
                } else {
                    // Orta seviye favori
                    overUnderOdds = {
                        'Over +2.5': 1.85,
                        'Under +2.5': 1.95
                    };
                }
            }
            
            let bttsOdds = {
                'Yes': 1.85,
                'No': 1.95
            };
            
            let bttsSource = 'hesaplandƒ±';
            
            if (odds['Both Teams To Score'] && typeof odds['Both Teams To Score'] === 'object') {
                bttsOdds = {
                    'Yes': parseFloat(odds['Both Teams To Score']['Yes'] || odds['Both Teams To Score'].yes || 1.85),
                    'No': parseFloat(odds['Both Teams To Score']['No'] || odds['Both Teams To Score'].no || 1.95)
                };
                bttsSource = 'API';
            } else if (odds.btts) {
                bttsOdds = {
                    'Yes': parseFloat(odds.btts.yes || 1.85),
                    'No': parseFloat(odds.btts.no || 1.95)
                };
                bttsSource = 'API';
            } else if (odds.both_score || odds.btts_yes) {
                bttsOdds = {
                    'Yes': parseFloat(odds.btts_yes || odds.both_score || 1.85),
                    'No': parseFloat(odds.btts_no || odds.neither_score || 1.95)
                };
                bttsSource = 'API';
            } else {
                // Ma√ß sonucu oranlarƒ±ndan BTTS tahmini
                const homeOdds = baseOdds['1'];
                const drawOdds = baseOdds['X'];
                const awayOdds = baseOdds['2'];
                const minOdds = Math.min(homeOdds, awayOdds);
                
                if (minOdds < 1.4) {
                    // √áok net favori - BTTS ihtimali d√º≈ü√ºk
                    bttsOdds = {
                        'Yes': 2.10,
                        'No': 1.70
                    };
                } else if (drawOdds < 3.0) {
                    // Beraberlik ihtimali y√ºksek - BTTS olabilir
                    bttsOdds = {
                        'Yes': 1.75,
                        'No': 2.05
                    };
                } else {
                    // Normal durum
                    bttsOdds = {
                        'Yes': 1.85,
                        'No': 1.95
                    };
                }
            }
            
            // √ñzet log (sadece hesaplananlar varsa)
            if (overUnderSource === 'hesaplandƒ±' || bttsSource === 'hesaplandƒ±') {
                console.log(`‚öôÔ∏è ${match.home_team || match.home}: Alt/√úst ${overUnderSource}, BTTS ${bttsSource}`);
            }
            
            return {
                ...baseOdds,
                'Over/Under +2.5': overUnderOdds,
                'Both Teams To Score': bttsOdds
            };
        }

        // ‚úÖ ANA ORAN √áEKME FONKSƒ∞YONU - Otomatik format tespiti
        function extractOdds(match) {
            // Nesine formatƒ± mƒ± kontrol et
            if (match.oranlar && Array.isArray(match.oranlar)) {
                console.log('üéØ Nesine formatƒ± tespit edildi');
                return extractOddsFromNesine(match);
            } 
            // Standart format
            else if (match.odds) {
                console.log(`üéØ Standart format tespit edildi (${match.home_team || match.home} vs ${match.away_team || match.away})`);
                return extractOddsStandard(match);
            }
            // Hi√ßbiri yoksa varsayƒ±lan
            else {
                console.warn('‚ö†Ô∏è Tanƒ±nmayan format, varsayƒ±lan deƒüerler kullanƒ±lƒ±yor');
                return {
                    '1': 2.0,
                    'X': 3.2,
                    '2': 3.5,
                    'Over/Under +2.5': { 'Over +2.5': 1.9, 'Under +2.5': 1.9 },
                    'Both Teams To Score': { 'Yes': 1.85, 'No': 1.95 }
                };
            }
        }

        function enhancedFindTeamStats(teamName) {
            if (!teamName || !teamStats) return null;
            
            if (teamStats[teamName]) {
                return teamStats[teamName];
            }
            
            const normalized = normalizeTeamName(teamName);
            
            if (normalized.length < 3) return null;
            
            for (const [csvTeam, stats] of Object.entries(teamStats)) {
                const csvNormalized = normalizeTeamName(csvTeam);
                
                if (csvNormalized === normalized) {
                    return stats;
                }
            }
            
            return null;
        }

        async function checkAPIStatus() {
            try {
                const apiStatusElement = document.getElementById('api-status');
                const response = await fetchWithTimeout(`${API_BASE_URL}/health`, 5000);
                
                if (response.ok) {
                    apiStatus = 'online';
                    apiStatusElement.innerHTML = 'üåê API: <span style="color: var(--success)">√áalƒ±≈üƒ±yor</span>';
                    apiStatusElement.classList.add('active');
                    document.getElementById('fetch-matches-btn').disabled = false;
                } else {
                    throw new Error('API not responding');
                }
            } catch (error) {
                apiStatus = 'offline';
                document.getElementById('api-status').innerHTML = 'üåê API: <span style="color: var(--danger)">Kapalƒ±</span>';
                document.getElementById('fetch-matches-btn').disabled = true;
            }
        }

        function fetchWithTimeout(url, timeout = 10000) {
            return Promise.race([
                fetch(url),
                new Promise((_, reject) =>
                    setTimeout(() => reject(new Error('Timeout')), timeout)
                )
            ]);
        }

        async function wakeUpAPI() {
            const wakeBtn = document.getElementById('wake-api-btn');
            const originalText = wakeBtn.innerHTML;
            
            wakeBtn.innerHTML = '‚è≥ API Uyandƒ±rƒ±lƒ±yor...';
            wakeBtn.disabled = true;
            
            showLoading('API uyandƒ±rƒ±lƒ±yor...', 'Render sunucusu ba≈ülatƒ±lƒ±yor (30-60 sn s√ºrebilir)');
            
            let attempts = 0;
            const maxAttempts = 10;
            
            try {
                console.log('üîî API uyandƒ±rma isteƒüi g√∂nderiliyor...');
                await fetch(`${API_BASE_URL}/api/matches/upcoming?force_refresh=true`, {
                    method: 'GET',
                    mode: 'cors'
                }).catch(e => {
                    console.log('‚ö†Ô∏è ƒ∞lk uyandƒ±rma isteƒüi ba≈üarƒ±sƒ±z, normal...');
                });
            } catch (e) {
                console.log('‚ö†Ô∏è Uyandƒ±rma isteƒüi hata verdi, normal...');
            }
            
            const checkInterval = setInterval(async () => {
                attempts++;
                
                showLoading(
                    `API uyandƒ±rƒ±lƒ±yor... (${attempts}/${maxAttempts})`,
                    'Sunucu ba≈ülatƒ±lmasƒ± bekleniyor...'
                );
                
                try {
                    const healthResponse = await fetchWithTimeout(`${API_BASE_URL}/health`, 10000);
                    
                    if (healthResponse.ok) {
                        clearInterval(checkInterval);
                        apiStatus = 'online';
                        
                        document.getElementById('api-status').innerHTML = 'üåê API: <span style="color: var(--success)">√áalƒ±≈üƒ±yor</span>';
                        document.getElementById('api-status').classList.add('active');
                        document.getElementById('fetch-matches-btn').disabled = false;
                        
                        wakeBtn.innerHTML = originalText;
                        wakeBtn.disabled = false;
                        
                        showSuccess(`
                            ‚úÖ API ba≈üarƒ±yla uyandƒ±rƒ±ldƒ±!<br>
                            üéØ Artƒ±k ma√ßlarƒ± y√ºkleyebilirsiniz.<br>
                            ‚è±Ô∏è Toplam s√ºre: ${attempts * 5} saniye
                        `);
                        
                        setTimeout(() => {
                            fetchMatches();
                        }, 2000);
                        
                        return;
                    }
                } catch (error) {
                    console.log(`‚è≥ Deneme ${attempts}/${maxAttempts}: API hen√ºz hazƒ±r deƒüil`);
                }
                
                if (attempts >= maxAttempts) {
                    clearInterval(checkInterval);
                    
                    wakeBtn.innerHTML = originalText;
                    wakeBtn.disabled = false;
                    
                    showError(`
                        ‚ùå API uyandƒ±rƒ±lamadƒ±!<br><br>
                        <strong>Olasƒ± nedenler:</strong><br>
                        ‚Ä¢ Render sunucusu √ßok yava≈ü ba≈ülƒ±yor<br>
                        ‚Ä¢ API tamamen kapalƒ± olabilir<br>
                        ‚Ä¢ ƒ∞nternet baƒülantƒ± sorunu<br><br>
                        <strong>√á√∂z√ºmler:</strong><br>
                        ‚Ä¢ Birka√ß dakika sonra tekrar deneyin<br>
                        ‚Ä¢ Manuel ma√ß ekle butonunu kullanƒ±n
                    `);
                }
            }, 5000);
        }

        function manualLoadCSV() {
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.csv';
            
            fileInput.onchange = async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                
                const startTime = Date.now();
                showLoading('CSV dosyasƒ± okunuyor...', `Dosya: ${file.name}`);
                
                try {
                    const csvContent = await file.text();
                    const loadTime = ((Date.now() - startTime) / 1000).toFixed(1);
                    
                    console.log(`‚úÖ Dosya okundu! S√ºre: ${loadTime}s`);
                    showLoading(`CSV dosyasƒ± i≈üleniyor... (${loadTime}s'de okundu)`, 'Takƒ±m istatistikleri hesaplanƒ±yor...');
                    
                    await parseAndLoadCSV(csvContent, 'Manuel');
                } catch (error) {
                    showError(`CSV y√ºklenemedi: ${error.message}`);
                }
            };
            
            fileInput.click();
        }

        async function loadHistoricalData() {
            const startTime = Date.now();
            const container = document.getElementById('match-container');
            
            container.innerHTML = `
                <div class="premium-loading">
                    <div class="loading-spinner"></div>
                    <div class="loading-text">Birle≈ütirilmi≈ü veri seti y√ºkleniyor...</div>
                    <div style="color: var(--text-muted); margin-top: 10px; font-size: 14px;">
                        <span id="load-status">112,869 ma√ßlƒ±k veri seti hazƒ±rlanƒ±yor...</span>
                    </div>
                </div>
            `;
            
            try {
                document.getElementById('load-status').textContent = 'Birle≈ütirilmi≈ü veri seti y√ºkleniyor (112,869 ma√ß)...';
                const dataUrl = 'https://raw.githubusercontent.com/devcem09-cmd/predicta-api/main/data/final_unified_dataset.csv';
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    controller.abort();
                }, 20000);
                
                const response = await fetch(dataUrl, { 
                    signal: controller.signal,
                    mode: 'cors',
                    cache: 'no-cache',
                    headers: {
                        'Accept': 'text/csv, text/plain, */*'
                    }
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                document.getElementById('load-status').textContent = 'Birle≈ütirilmi≈ü veri i≈üleniyor...';
                const csvContent = await response.text();
                
                document.getElementById('load-status').textContent = 'Takƒ±m istatistikleri hesaplanƒ±yor...';
                await parseAndLoadUnifiedCSV(csvContent);
                
            } catch (error) {
                console.error('‚ùå Birle≈ütirilmi≈ü veri y√ºkleme hatasƒ±:', error);
                
                try {
                    showLoading('Birle≈ütirilmi≈ü veri y√ºklenemedi, eski veri deneniyor...');
                    await loadFallbackData();
                } catch (fallbackError) {
                    container.innerHTML = `
                        <div class="premium-alert warning">
                            ‚ùå Veri y√ºkleme ba≈üarƒ±sƒ±z<br>
                            <strong>Hata:</strong> ${error.message}<br><br>
                            
                            <strong>√á√∂z√ºm se√ßenekleri:</strong><br><br>
                            <button class="premium-btn" onclick="loadHistoricalData()" style="margin: 10px 5px;">
                                üîÑ Tekrar Dene
                            </button>
                            <button class="premium-btn secondary" onclick="manualLoadCSV()" style="margin: 10px 5px;">
                                üìÇ Manuel CSV Y√ºkle
                            </button>
                            <button class="premium-btn" onclick="loadManualMatches()" style="margin: 10px 5px;">
                                üß™ Manuel Ma√ß Ekle
                            </button>
                        </div>
                    `;
                }
            }
        }

        async function parseAndLoadCSV(csvContent, source = 'Dosya') {
            const parseStart = Date.now();
            
            try {
                const lines = csvContent.split('\n').filter(line => line.trim());
                const matches = [];
                
                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',');
                    if (values.length >= 7) {
                        matches.push({
                            home_team: values[0]?.trim(),
                            away_team: values[1]?.trim(),
                            date: values[2]?.trim(),
                            home_score: parseInt(values[3]) || 0,
                            away_score: parseInt(values[4]) || 0,
                            result: values[5]?.trim(),
                            league: values[6]?.trim()
                        });
                    }
                }
                
                historicalData = matches.filter(m => m.home_team && m.away_team);
                
                if (historicalData.length === 0) {
                    throw new Error('CSV dosyasƒ±nda ge√ßerli veri bulunamadƒ±');
                }
                
                calculateTeamStats();
                
                const parseTime = ((Date.now() - parseStart) / 1000).toFixed(1);
                
                document.getElementById('csv-status').innerHTML = `‚úÖ CSV: ${historicalData.length} ma√ß`;
                document.getElementById('csv-status').classList.add('active');
                
                showSuccess(`
                    ‚úÖ ${historicalData.length} ge√ßmi≈ü ma√ß y√ºklendi! (${source})<br>
                    üìä ${Object.keys(teamStats).length} takƒ±mƒ±n istatistikleri hazƒ±r!<br>
                    ‚ö° ƒ∞≈ülem s√ºresi: ${parseTime}s<br><br>
                    üéØ Artƒ±k "<strong>Ma√ßlarƒ± Y√ºkle</strong>" ile devam edebilirsiniz!
                `);
                
            } catch (error) {
                showError(`CSV i≈ülenemedi: ${error.message}`);
            }
        }

        function calculateTeamStats() {
            teamStats = {};
            
            for (let i = 0; i < historicalData.length; i++) {
                const match = historicalData[i];
                
                if (!teamStats[match.home_team]) {
                    teamStats[match.home_team] = {
                        played: 0, wins: 0, draws: 0, losses: 0,
                        goalsFor: 0, goalsAgainst: 0,
                        homeGames: 0, homeWins: 0, homeDraws: 0, homeLosses: 0,
                        awayGames: 0, awayWins: 0, awayDraws: 0, awayLosses: 0,
                        homeGoalsFor: 0, homeGoalsAgainst: 0,
                        awayGoalsFor: 0, awayGoalsAgainst: 0,
                        recentForm: [],
                        h2h: {}
                    };
                }
                
                if (!teamStats[match.away_team]) {
                    teamStats[match.away_team] = {
                        played: 0, wins: 0, draws: 0, losses: 0,
                        goalsFor: 0, goalsAgainst: 0,
                        homeGames: 0, homeWins: 0, homeDraws: 0, homeLosses: 0,
                        awayGames: 0, awayWins: 0, awayDraws: 0, awayLosses: 0,
                        homeGoalsFor: 0, homeGoalsAgainst: 0,
                        awayGoalsFor: 0, awayGoalsAgainst: 0,
                        recentForm: [],
                        h2h: {}
                    };
                }
                
                const homeStats = teamStats[match.home_team];
                const awayStats = teamStats[match.away_team];
                
                homeStats.played++;
                homeStats.homeGames++;
                homeStats.goalsFor += match.home_score;
                homeStats.goalsAgainst += match.away_score;
                homeStats.homeGoalsFor += match.home_score;
                homeStats.homeGoalsAgainst += match.away_score;
                
                if (match.home_score > match.away_score) {
                    homeStats.wins++;
                    homeStats.homeWins++;
                    homeStats.recentForm.push('W');
                } else if (match.home_score === match.away_score) {
                    homeStats.draws++;
                    homeStats.homeDraws++;
                    homeStats.recentForm.push('D');
                } else {
                    homeStats.losses++;
                    homeStats.homeLosses++;
                    homeStats.recentForm.push('L');
                }
                
                awayStats.played++;
                awayStats.awayGames++;
                awayStats.goalsFor += match.away_score;
                awayStats.goalsAgainst += match.home_score;
                awayStats.awayGoalsFor += match.away_score;
                awayStats.awayGoalsAgainst += match.home_score;
                
                if (match.away_score > match.home_score) {
                    awayStats.wins++;
                    awayStats.awayWins++;
                    awayStats.recentForm.push('W');
                } else if (match.away_score === match.home_score) {
                    awayStats.draws++;
                    awayStats.awayDraws++;
                    awayStats.recentForm.push('D');
                } else {
                    awayStats.losses++;
                    awayStats.awayLosses++;
                    awayStats.recentForm.push('L');
                }
                
                if (!homeStats.h2h[match.away_team]) {
                    homeStats.h2h[match.away_team] = { wins: 0, draws: 0, losses: 0, goalsFor: 0, goalsAgainst: 0 };
                }
                if (!awayStats.h2h[match.home_team]) {
                    awayStats.h2h[match.home_team] = { wins: 0, draws: 0, losses: 0, goalsFor: 0, goalsAgainst: 0 };
                }
                
                if (match.home_score > match.away_score) {
                    homeStats.h2h[match.away_team].wins++;
                    awayStats.h2h[match.home_team].losses++;
                } else if (match.home_score === match.away_score) {
                    homeStats.h2h[match.away_team].draws++;
                    awayStats.h2h[match.home_team].draws++;
                } else {
                    homeStats.h2h[match.away_team].losses++;
                    awayStats.h2h[match.home_team].wins++;
                }
                
                homeStats.h2h[match.away_team].goalsFor += match.home_score;
                homeStats.h2h[match.away_team].goalsAgainst += match.away_score;
                awayStats.h2h[match.home_team].goalsFor += match.away_score;
                awayStats.h2h[match.home_team].goalsAgainst += match.home_score;
            }
        }

        function normalizeTeamName(name) {
            if (!name) return '';
            return name
                .toLowerCase()
                .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
                .replace(/\s+/g, ' ')
                .replace(/[.-]/g, ' ')
                .replace(/'/g, '')
                .replace(/\b(fc|sk|sc|as|fk|bk|jk|tk|cf|cd|ud|ac|ca|ec|rc|club|atletico|sporting|real|deportivo)\b/gi, '')
                .replace(/\s+/g, ' ')
                .trim();
        }

        function smartPredict(match) {
            const odds = extractOdds(match);
            
            if (!odds['1'] || !odds['X'] || !odds['2']) {
                return null;
            }

            // Nesine formatƒ±nda takƒ±m isimlerini kontrol et
            const homeTeam = match.home || match.home_team;
            const awayTeam = match.away || match.away_team;

            const homeStats = enhancedFindTeamStats(homeTeam);
            const awayStats = enhancedFindTeamStats(awayTeam);

            const oddsAnalysis = analyzeOdds(odds);
            const formAnalysis = analyzeForm(homeTeam, awayTeam, homeStats, awayStats);
            const h2hAnalysis = analyzeH2H(homeTeam, awayTeam, homeStats, awayStats);
            const venueAnalysis = analyzeVenue(homeTeam, awayTeam, homeStats, awayStats);

            let scores = {
                '1': oddsAnalysis.homeWinProb * 0.40,
                'X': oddsAnalysis.drawProb * 0.40,
                '2': oddsAnalysis.awayWinProb * 0.40
            };

            if (formAnalysis.dataAvailable) {
                scores['1'] += formAnalysis.homeForm * 0.25;
                scores['2'] += formAnalysis.awayForm * 0.25;
                
                const formDiff = Math.abs(formAnalysis.homeForm - formAnalysis.awayForm);
                if (formDiff < 0.2) {
                    scores['X'] += 0.15;
                }
            }

            if (h2hAnalysis.dataAvailable) {
                if (h2hAnalysis.advantage === 'home') {
                    scores['1'] += 0.20;
                } else if (h2hAnalysis.advantage === 'away') {
                    scores['2'] += 0.20;
                } else if (h2hAnalysis.advantage === 'draw') {
                    scores['X'] += 0.15;
                }
            }

            if (venueAnalysis.dataAvailable) {
                if (venueAnalysis.homeAdvantage) {
                    scores['1'] += venueAnalysis.homeAdvantage * 0.15;
                }
                if (venueAnalysis.awayAdvantage) {
                    scores['2'] += venueAnalysis.awayAdvantage * 0.15;
                }
            }

            let prediction = '1';
            let maxScore = scores['1'];
            if (scores['X'] > maxScore) {
                prediction = 'X';
                maxScore = scores['X'];
            }
            if (scores['2'] > maxScore) {
                prediction = '2';
                maxScore = scores['2'];
            }

            const totalScore = scores['1'] + scores['X'] + scores['2'];
            let confidence = maxScore / totalScore;

            if (prediction === 'X') {
                confidence = Math.min(confidence * 0.85, 0.65);
            }

            const dataQuality = (
                (formAnalysis.dataAvailable ? 0.25 : 0) +
                (h2hAnalysis.dataAvailable ? 0.20 : 0) +
                (venueAnalysis.dataAvailable ? 0.15 : 0)
            ) / 0.60;
            
            confidence = confidence * (0.7 + (dataQuality * 0.3));

            const overUnder = predictOverUnder(odds, prediction, formAnalysis, venueAnalysis);
            const btts = predictBTTS(odds, oddsAnalysis, formAnalysis);

            return {
                prediction,
                confidence,
                dataQuality,
                analysis: {
                    odds: oddsAnalysis,
                    form: formAnalysis,
                    h2h: h2hAnalysis,
                    venue: venueAnalysis,
                    scores
                },
                over_under: overUnder,
                btts: btts
            };
        }

        function analyzeOdds(odds) {
            const home = parseFloat(odds['1']);
            const draw = parseFloat(odds['X']);
            const away = parseFloat(odds['2']);

            const homeProb = 1 / home;
            const drawProb = 1 / draw;
            const awayProb = 1 / away;
            
            const total = homeProb + drawProb + awayProb;
            
            const homeWinProb = homeProb / total;
            const drawProbNorm = drawProb / total;
            const awayWinProb = awayProb / total;

            let favorite = 'draw';
            if (home < draw && home < away) favorite = 'home';
            else if (away < draw && away < home) favorite = 'away';

            return {
                homeWinProb,
                drawProb: drawProbNorm,
                awayWinProb,
                favorite,
                homeOdds: home,
                drawOdds: draw,
                awayOdds: away
            };
        }

        function analyzeForm(homeTeam, awayTeam, homeStats = null, awayStats = null) {
            if (!homeStats || !awayStats) {
                homeStats = enhancedFindTeamStats(homeTeam);
                awayStats = enhancedFindTeamStats(awayTeam);
            }
            
            if (!homeStats || !awayStats) {
                return { 
                    homeForm: null, 
                    awayForm: null, 
                    weight: 0.25,
                    dataAvailable: false 
                };
            }

            const calculateFormScore = (form) => {
                const last5 = form.slice(-5);
                let score = 0;
                last5.forEach((result, index) => {
                    const weight = (index + 1) / 5;
                    if (result === 'W') score += 1 * weight;
                    else if (result === 'D') score += 0.5 * weight;
                });
                return last5.length > 0 ? score / last5.length : 0.5;
            };

            const homeFormScore = calculateFormScore(homeStats.recentForm);
            const awayFormScore = calculateFormScore(awayStats.recentForm);

            return {
                homeForm: homeFormScore,
                awayForm: awayFormScore,
                homeFormStr: homeStats.recentForm.slice(-5).join(''),
                awayFormStr: awayStats.recentForm.slice(-5).join(''),
                weight: 0.25,
                dataAvailable: true
            };
        }

        function analyzeH2H(homeTeam, awayTeam, homeStats = null, awayStats = null) {
            if (!homeStats || !awayStats) {
                homeStats = enhancedFindTeamStats(homeTeam);
                awayStats = enhancedFindTeamStats(awayTeam);
            }
            
            if (!homeStats || !awayStats) {
                return { 
                    advantage: 'none', 
                    weight: 0.20,
                    dataAvailable: false 
                };
            }

            const homeH2H = homeStats.h2h[awayTeam] || homeStats.h2h[normalizeTeamName(awayTeam)];
            
            if (!homeH2H || (homeH2H.wins + homeH2H.draws + homeH2H.losses) === 0) {
                return { 
                    advantage: 'none', 
                    weight: 0.10,
                    dataAvailable: false,
                    totalGames: 0
                };
            }

            const totalGames = homeH2H.wins + homeH2H.draws + homeH2H.losses;
            const homeWinRate = homeH2H.wins / totalGames;
            const drawRate = homeH2H.draws / totalGames;

            let advantage = 'none';
            if (homeWinRate >= 0.5) advantage = 'home';
            else if (drawRate >= 0.4) advantage = 'draw';
            else advantage = 'away';

            return {
                advantage,
                homeWins: homeH2H.wins,
                draws: homeH2H.draws,
                awayWins: homeH2H.losses,
                totalGames,
                avgGoalsFor: (homeH2H.goalsFor / totalGames).toFixed(1),
                avgGoalsAgainst: (homeH2H.goalsAgainst / totalGames).toFixed(1),
                weight: 0.20,
                dataAvailable: true
            };
        }

        function analyzeVenue(homeTeam, awayTeam, homeStats = null, awayStats = null) {
            if (!homeStats || !awayStats) {
                homeStats = enhancedFindTeamStats(homeTeam);
                awayStats = enhancedFindTeamStats(awayTeam);
            }
            
            if (!homeStats || !awayStats) {
                return { 
                    homeAdvantage: 0, 
                    awayAdvantage: 0,
                    dataAvailable: false 
                };
            }

            const homeWinRate = homeStats.homeGames > 0 ? 
                homeStats.homeWins / homeStats.homeGames : 0.5;
            
            const awayWinRate = awayStats.awayGames > 0 ? 
                awayStats.awayWins / awayStats.awayGames : 0.3;

            const homeAvgGoalsFor = homeStats.homeGames > 0 ? 
                homeStats.homeGoalsFor / homeStats.homeGames : 1.5;
            const awayAvgGoalsFor = awayStats.awayGames > 0 ? 
                awayStats.awayGoalsFor / awayStats.awayGames : 1.0;

            return {
                homeAdvantage: homeWinRate,
                awayAdvantage: awayWinRate,
                homeAvgGoals: homeAvgGoalsFor.toFixed(2),
                awayAvgGoals: awayAvgGoalsFor.toFixed(2),
                homeWinRate: (homeWinRate * 100).toFixed(0),
                awayWinRate: (awayWinRate * 100).toFixed(0),
                dataAvailable: true
            };
        }

        function predictOverUnder(odds, matchPrediction, formAnalysis, venueAnalysis) {
            const overUnderOdds = odds['Over/Under +2.5'];
            const overOdds = parseFloat(overUnderOdds['Over +2.5']);
            const underOdds = parseFloat(overUnderOdds['Under +2.5']);
            
            let prediction = 'over';
            let confidence = 0.55;

            const minOdds = Math.min(overOdds, underOdds);
            if (minOdds < 1.70) {
                prediction = overOdds < underOdds ? 'over' : 'under';
                confidence = 0.62;
            } else if (overOdds > underOdds) {
                prediction = 'under';
                confidence = 0.60;
            } else if (overOdds >= 2.0 && overOdds <= 3.5 && underOdds >= 2.0 && underOdds <= 3.5) {
                prediction = 'over';
                confidence = 0.58;
            }

            if (venueAnalysis.homeAvgGoals && venueAnalysis.awayAvgGoals) {
                const totalAvgGoals = parseFloat(venueAnalysis.homeAvgGoals) + 
                                     parseFloat(venueAnalysis.awayAvgGoals);
                
                if (totalAvgGoals > 2.7) {
                    prediction = 'over';
                    confidence = Math.min(confidence + 0.08, 0.70);
                } else if (totalAvgGoals < 2.2) {
                    prediction = 'under';
                    confidence = Math.min(confidence + 0.06, 0.68);
                }
            }

            if (matchPrediction === '1' || matchPrediction === '2') {
                if (prediction === 'under') {
                    prediction = 'over';
                    confidence = Math.min(confidence + 0.05, 0.65);
                }
            }

            return { prediction, confidence };
        }

        function predictBTTS(odds, oddsAnalysis, formAnalysis) {
            const bttsOdds = odds['Both Teams To Score'];
            const yesOdds = parseFloat(bttsOdds['Yes']);
            const noOdds = parseFloat(bttsOdds['No']);
            
            let prediction = true;
            let confidence = 0.52;

            if (yesOdds < noOdds) {
                prediction = true;
                confidence = 0.58;
            } else if (oddsAnalysis.favorite !== 'draw') {
                const favoriteOdds = oddsAnalysis.favorite === 'home' ? 
                    parseFloat(odds['1']) : parseFloat(odds['2']);
                
                if (favoriteOdds < 1.5) {
                    prediction = false;
                    confidence = 0.62;
                }
            }

            return { prediction, confidence };
        }

        async function fetchMatches() {
            if (apiStatus === 'offline') {
                showError('API kapalƒ±! L√ºtfen √∂nce "API\'yi Uyandƒ±r" butonuna tƒ±klayƒ±n.');
                return;
            }

            showLoading('Ma√ßlar y√ºkleniyor...');
            
            try {
                const response = await fetch(`${API_BASE_URL}/api/matches/upcoming?force_refresh=true`, {
                    mode: 'cors',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const data = await response.json();
                
                if (data.success && Array.isArray(data.matches)) {
                    allMatches = data.matches;
                    
                    if (allMatches.length > 0) {
                        console.log('üìä ƒ∞lk ma√ßƒ±n oran yapƒ±sƒ±:', JSON.stringify(allMatches[0], null, 2));
                        console.log('‚ÑπÔ∏è Eksik oranlar (Alt/√úst, BTTS) ma√ß sonucu oranlarƒ±ndan otomatik hesaplanacak');
                    }
                    
                    updateMatchCount();
                    displayMatches(allMatches);
                    document.getElementById('predict-all-btn').disabled = false;
                    
                    showSuccess(`‚úÖ ${allMatches.length} ma√ß y√ºklendi!<br>‚ÑπÔ∏è Eksik oranlar akƒ±llƒ± algoritma ile tamamlanacak`);
                } else {
                    throw new Error('Ge√ßersiz veri');
                }
            } catch (error) {
                showError(`Ma√ßlar y√ºklenemedi: ${error.message}`);
                apiStatus = 'offline';
                document.getElementById('api-status').innerHTML = 'üåê API: <span style="color: var(--danger)">Kapalƒ±</span>';
                document.getElementById('fetch-matches-btn').disabled = true;
            }
        }

        function loadManualMatches() {
            allMatches = [
                {
                    match_id: 'manual1',
                    home_team: 'Hobro',
                    away_team: 'Hvidovre',
                    date: new Date(Date.now() + 86400000).toISOString(),
                    league_name: '1st Division',
                    league_code: 'DK1',
                    odds: {
                        '1': 2.7,
                        'X': 2.98, 
                        '2': 1.97,
                        'Over/Under +2.5': { 'Over +2.5': 1.9, 'Under +2.5': 1.9 },
                        'Both Teams To Score': { 'Yes': 1.85, 'No': 1.95 }
                    }
                },
                {
                    match_id: 'manual2',
                    home_team: 'Galatasaray',
                    away_team: 'Fenerbah√ße',
                    date: new Date(Date.now() + 86400000).toISOString(),
                    league_name: 'S√ºper Lig',
                    league_code: 'TR1',
                    odds: {
                        '1': 2.10,
                        'X': 3.20, 
                        '2': 3.50,
                        'Over/Under +2.5': { 'Over +2.5': 1.90, 'Under +2.5': 1.95 },
                        'Both Teams To Score': { 'Yes': 1.85, 'No': 1.95 }
                    }
                }
            ];
            
            updateMatchCount();
            displayMatches(allMatches);
            document.getElementById('predict-all-btn').disabled = false;
            document.getElementById('filter-panel').style.display = 'block';
            
            showSuccess(`‚úÖ ${allMatches.length} manuel ma√ß y√ºklendi! Analiz yapabilirsiniz.`);
        }

        async function predictAllMatches() {
            if (!historicalData) {
                showError('√ñnce CSV dosyasƒ±nƒ± y√ºkleyin!');
                return;
            }

            const predictBtn = document.getElementById('predict-all-btn');
            predictBtn.disabled = true;
            predictBtn.innerHTML = '‚è≥ Analiz Ediliyor...';
            
            showLoading('Geli≈ümi≈ü analiz yapƒ±lƒ±yor...', 'Oranlar, form, H2H ve ev/deplasman analizi');
            
            predictions = {};
            let successCount = 0;

            for (let i = 0; i < allMatches.length; i++) {
                const match = allMatches[i];
                
                const prediction = smartPredict(match);
                
                if (prediction) {
                    predictions[match.match_id || match.mac_id] = prediction;
                    successCount++;
                }
                
                showLoading(
                    `Analiz ediliyor: ${i + 1}/${allMatches.length}`,
                    `‚úÖ ${successCount} ma√ß analiz edildi`
                );
                
                await new Promise(resolve => setTimeout(resolve, 50));
            }
            
            document.getElementById('filter-panel').style.display = 'block';
            
            displayMatches(allMatches);
            predictBtn.disabled = false;
            predictBtn.innerHTML = 'üéØ Geli≈ümi≈ü Analiz Yap';
            updatePredictionCount();
            
            showSuccess(`‚úÖ ${successCount} ma√ß i√ßin geli≈ümi≈ü tahmin √ºretildi!`);
        }

        function applyFilters() {
            const dateFilter = document.getElementById('filter-date').value;
            const confidenceFilter = parseInt(document.getElementById('filter-confidence').value);
            const sortFilter = document.getElementById('filter-sort').value;
            
            let filteredMatches = [...allMatches];
            
            if (dateFilter !== 'all') {
                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const tomorrow = new Date(today);
                tomorrow.setDate(tomorrow.getDate() + 1);
                
                filteredMatches = filteredMatches.filter(match => {
                    const matchDate = new Date(match.date);
                    const matchDay = new Date(matchDate.getFullYear(), matchDate.getMonth(), matchDate.getDate());
                    
                    if (dateFilter === 'today') {
                        return matchDay.getTime() === today.getTime();
                    } else if (dateFilter === 'tomorrow') {
                        return matchDay.getTime() === tomorrow.getTime();
                    }
                    return true;
                });
            }
            
            if (confidenceFilter > 0) {
                filteredMatches = filteredMatches.filter(match => {
                    const matchId = match.match_id || match.mac_id;
                    const pred = predictions[matchId];
                    return pred && (pred.confidence * 100) >= confidenceFilter;
                });
            }
            
            if (sortFilter === 'confidence-desc') {
                filteredMatches.sort((a, b) => {
                    const matchIdA = a.match_id || a.mac_id;
                    const matchIdB = b.match_id || b.mac_id;
                    const predA = predictions[matchIdA];
                    const predB = predictions[matchIdB];
                    return (predB?.confidence || 0) - (predA?.confidence || 0);
                });
            } else if (sortFilter === 'confidence-asc') {
                filteredMatches.sort((a, b) => {
                    const matchIdA = a.match_id || a.mac_id;
                    const matchIdB = b.match_id || b.mac_id;
                    const predA = predictions[matchIdA];
                    const predB = predictions[matchIdB];
                    return (predA?.confidence || 0) - (predB?.confidence || 0);
                });
            } else if (sortFilter === 'date-asc') {
                filteredMatches.sort((a, b) => new Date(a.date) - new Date(b.date));
            } else if (sortFilter === 'quality-desc') {
                filteredMatches.sort((a, b) => {
                    const matchIdA = a.match_id || a.mac_id;
                    const matchIdB = b.match_id || b.mac_id;
                    const predA = predictions[matchIdA];
                    const predB = predictions[matchIdB];
                    return (predB?.dataQuality || 0) - (predA?.dataQuality || 0);
                });
            }
            
            displayMatches(filteredMatches);
        }
        
        function resetFilters() {
            document.getElementById('filter-date').value = 'all';
            document.getElementById('filter-confidence').value = '0';
            document.getElementById('filter-sort').value = 'default';
            displayMatches(allMatches);
        }

        function displayMatches(matches) {
            const container = document.getElementById('match-container');
            
            if (matches.length === 0) {
                container.innerHTML = `
                    <div class="premium-alert warning">
                        Hen√ºz ma√ß y√ºklenmedi. "Ma√ßlarƒ± Y√ºkle" butonuna tƒ±klayƒ±n.
                    </div>
                `;
                return;
            }
            
            container.innerHTML = '';
            
            matches.forEach(match => {
                const matchId = match.match_id || match.mac_id;
                const prediction = predictions[matchId];
                const card = createMatchCard(match, prediction);
                container.appendChild(card);
            });
        }

        function createMatchCard(match, prediction) {
            const card = document.createElement('div');
            card.className = 'premium-match-card';
            
            const hasPrediction = prediction && prediction.prediction;
            const confidence = hasPrediction ? (prediction.confidence * 100).toFixed(0) : 0;
            const pred = hasPrediction ? prediction.prediction : '?';
            
            if (hasPrediction) {
                if (confidence >= 70) {
                    card.style.borderLeftColor = 'var(--success)';
                    card.style.borderLeftWidth = '5px';
                } else if (confidence >= 60) {
                    card.style.borderLeftColor = 'var(--primary)';
                    card.style.borderLeftWidth = '4px';
                }
            }
            
            const overUnder = prediction?.over_under || {};
            const btts = prediction?.btts || {};
            const formAnalysis = prediction?.analysis?.form || {};
            const h2hAnalysis = prediction?.analysis?.h2h || {};
            const venueAnalysis = prediction?.analysis?.venue || {};
            
            const odds = extractOdds(match);
            
            // Nesine ve standart format i√ßin takƒ±m isimleri
            const homeTeam = match.home || match.home_team;
            const awayTeam = match.away || match.away_team;
            const leagueName = match.league_name || 'Bilinmiyor';
            
            // Tarih formatƒ± - Nesine formatƒ± da destekler
            let dateStr = '';
            if (match.tarih && match.saat) {
                dateStr = `${match.tarih} ${match.saat}`;
            } else if (match.date) {
                dateStr = new Date(match.date).toLocaleDateString('tr-TR', {
                    day: '2-digit',
                    month: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            }
            
            card.innerHTML = `
                <div class="match-header">
                    <div class="team-info">
                        <div class="match-teams">
                            ${homeTeam}<span class="vs-separator">VS</span>${awayTeam}
                        </div>
                        <div class="match-meta">
                            <span class="meta-badge">üèÜ ${leagueName}</span>
                            <span class="meta-badge">üìÖ ${dateStr}</span>
                        </div>
                    </div>
                    
                    <div class="prediction-panel">
                        <div class="prediction-header">üìä TAHMƒ∞NLER & ORANLAR</div>
                        
                        <div class="odds-row">
                            <div class="odds-label">Ma√ß Sonucu:</div>
                            <div class="odds-values">
                                <div class="odd-item ${pred === '1' ? 'selected' : ''}">${odds['1']}</div>
                                <div class="odd-item ${pred === 'X' ? 'selected' : ''}">${odds['X']}</div>
                                <div class="odd-item ${pred === '2' ? 'selected' : ''}">${odds['2']}</div>
                            </div>
                        </div>
                        
                        <div class="odds-row">
                            <div class="odds-label">Alt/√úst 2.5:</div>
                            <div class="odds-values">
                                <div class="odd-item ${overUnder.prediction === 'over' ? 'selected' : ''}">${odds['Over/Under +2.5']['Over +2.5']}</div>
                                <div class="odd-item ${overUnder.prediction === 'under' ? 'selected' : ''}">${odds['Over/Under +2.5']['Under +2.5']}</div>
                            </div>
                        </div>
                        
                        <div class="odds-row">
                            <div class="odds-label">KG Var/Yok:</div>
                            <div class="odds-values">
                                <div class="odd-item ${btts.prediction === true ? 'selected' : ''}">${odds['Both Teams To Score']['Yes']}</div>
                                <div class="odd-item ${btts.prediction === false ? 'selected' : ''}">${odds['Both Teams To Score']['No']}</div>
                            </div>
                        </div>
                        
                        ${hasPrediction ? `
                            <div class="confidence-meter" style="border-color: ${confidence >= 70 ? 'var(--success)' : confidence >= 60 ? 'var(--primary)' : 'var(--secondary)'}">
                                <span style="font-size: 10px; color: var(--text-muted);">G√ºven</span>
                                <span class="confidence-value" style="color: ${confidence >= 70 ? 'var(--success)' : confidence >= 60 ? 'var(--primary)' : 'var(--secondary)'}">%${confidence}</span>
                            </div>
                            ${prediction.dataQuality !== undefined ? `
                            <div class="data-quality">
                                <span style="color: var(--text-muted);">Veri Kalitesi: </span>
                                <span style="color: ${prediction.dataQuality >= 0.8 ? 'var(--success)' : prediction.dataQuality >= 0.5 ? 'var(--primary)' : 'var(--danger)'}; font-weight: 700;">
                                    %${(prediction.dataQuality * 100).toFixed(0)}
                                </span>
                            </div>
                            ` : ''}
                        ` : '<div style="text-align: center; padding: 10px; color: var(--text-muted); font-size: 11px;">Analiz bekleniyor...</div>'}
                    </div>
                </div>
                
                ${hasPrediction && (h2hAnalysis.totalGames || venueAnalysis.homeAvgGoals) ? `
                    <div class="analysis-section">
                        <div class="analysis-title">üìä Detaylƒ± Analiz</div>
                        <div class="analysis-grid">
                            ${h2hAnalysis.totalGames ? `
                            <div class="analysis-card">
                                <div class="analysis-card-title">ü§ù H2H (${h2hAnalysis.totalGames} ma√ß)</div>
                                <div style="margin-top: 5px; font-size: 9px;">
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 2px;">
                                        <span style="color: var(--text-muted);">Ev:</span>
                                        <span style="color: var(--success); font-weight: 700;">${h2hAnalysis.homeWins}G</span>
                                    </div>
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 2px;">
                                        <span style="color: var(--text-muted);">Berabere:</span>
                                        <span style="color: var(--primary); font-weight: 700;">${h2hAnalysis.draws}B</span>
                                    </div>
                                    <div style="display: flex; justify-content: space-between;">
                                        <span style="color: var(--text-muted);">Deplasman:</span>
                                        <span style="color: var(--danger); font-weight: 700;">${h2hAnalysis.awayWins}G</span>
                                    </div>
                                </div>
                            </div>
                            ` : ''}
                            
                            ${venueAnalysis.homeAvgGoals ? `
                            <div class="analysis-card">
                                <div class="analysis-card-title">üü¢ Ev/Deplasman</div>
                                <div style="margin-top: 5px; font-size: 9px;">
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 2px;">
                                        <span style="color: var(--text-muted);">Ev Kazanma:</span>
                                        <span style="color: var(--primary); font-weight: 700;">${venueAnalysis.homeWinRate}%</span>
                                    </div>
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 2px;">
                                        <span style="color: var(--text-muted);">Deplasman:</span>
                                        <span style="color: var(--primary); font-weight: 700;">${venueAnalysis.awayWinRate}%</span>
                                    </div>
                                    <div style="display: flex; justify-content: space-between;">
                                        <span style="color: var(--text-muted);">Ort. Gol:</span>
                                        <span style="color: var(--success); font-weight: 700;">${venueAnalysis.homeAvgGoals} - ${venueAnalysis.awayAvgGoals}</span>
                                    </div>
                                </div>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                ` : ''}
            `;
            
            return card;
        }

        function clearAll() {
            allMatches = [];
            predictions = {};
            
            document.getElementById('match-container').innerHTML = `
                <div class="premium-alert warning">
                    Ma√ßlar temizlendi. "Ma√ßlarƒ± Y√ºkle" butonuna tƒ±klayƒ±n.
                </div>
            `;
            updateMatchCount();
            updatePredictionCount();
            document.getElementById('predict-all-btn').disabled = true;
        }

        function showLoading(message, subtext = '') {
            const container = document.getElementById('match-container');
            container.innerHTML = `
                <div class="premium-loading">
                    <div class="loading-spinner"></div>
                    <div class="loading-text">${message}</div>
                    ${subtext ? `<div style="color: var(--text-muted); margin-top: 10px; font-size: 14px;">${subtext}</div>` : ''}
                </div>
            `;
        }

        function showError(message) {
            const container = document.getElementById('match-container');
            container.innerHTML = `<div class="premium-alert" style="border-color: var(--danger); background: rgba(239, 68, 68, 0.2);">‚ùå ${message}</div>`;
        }

        function showSuccess(message) {
            const container = document.getElementById('match-container');
            const alert = document.createElement('div');
            alert.className = 'premium-alert success';
            alert.innerHTML = message;
            container.insertBefore(alert, container.firstChild);
            setTimeout(() => alert.remove(), 5000);
        }

        function updateMatchCount() {
            document.getElementById('match-count').textContent = allMatches.length;
        }

        function updatePredictionCount() {
            document.getElementById('prediction-count').textContent = Object.keys(predictions).length;
        }

        async function parseAndLoadUnifiedCSV(csvContent) {
            const parseStart = Date.now();
            
            try {
                const lines = csvContent.split('\n').filter(line => line.trim());
                const matches = [];
                
                const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
                console.log('üìã Birle≈ütirilmi≈ü veri s√ºtunlarƒ±:', headers);
                
                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',');
                    if (values.length >= headers.length) {
                        const match = {};
                        headers.forEach((header, index) => {
                            match[header] = values[index]?.trim();
                        });
                        
                        if (match.home_score && match.away_score) {
                            match.home_score = parseInt(match.home_score) || 0;
                            match.away_score = parseInt(match.away_score) || 0;
                            
                            if (!match.result) {
                                if (match.home_score > match.away_score) {
                                    match.result = '1';
                                } else if (match.home_score < match.away_score) {
                                    match.result = '2';
                                } else {
                                    match.result = 'X';
                                }
                            }
                        }
                        
                        if (match.home_team && match.away_team && match.home_team.length > 1 && match.away_team.length > 1) {
                            matches.push(match);
                        }
                    }
                }
                
                historicalData = matches;
                
                if (historicalData.length === 0) {
                    throw new Error('Birle≈ütirilmi≈ü CSV dosyasƒ±nda ge√ßerli veri bulunamadƒ±');
                }
                
                calculateTeamStats();
                
                const parseTime = ((Date.now() - parseStart) / 1000).toFixed(1);
                
                document.getElementById('csv-status').innerHTML = `‚úÖ CSV: ${historicalData.length} ma√ß`;
                document.getElementById('csv-status').classList.add('active');
                
                console.log(`‚úÖ Birle≈ütirilmi≈ü istatistikler hesaplandƒ±! S√ºre: ${parseTime}s`);
                console.log(`üìä ${Object.keys(teamStats).length} takƒ±m analiz edildi`);
                
                showSuccess(`
                    ‚úÖ ${historicalData.length} birle≈ütirilmi≈ü ma√ß y√ºklendi!<br>
                    üìä ${Object.keys(teamStats).length} takƒ±mƒ±n istatistikleri hazƒ±r!<br>
                    ‚ö° ƒ∞≈ülem s√ºresi: ${parseTime}s<br><br>
                    üéØ Artƒ±k "<strong>Ma√ßlarƒ± Y√ºkle</strong>" ile devam edebilirsiniz!
                `);
                
            } catch (error) {
                showError(`Birle≈ütirilmi≈ü CSV i≈ülenemedi: ${error.message}`);
            }
        }

        async function loadFallbackData() {
            console.log('üîÑ Fallback veri y√ºkleniyor...');
            const fallbackUrl = 'https://raw.githubusercontent.com/devcem09-cmd/predicta-api/main/data/merged_all.csv';
            
            const response = await fetch(fallbackUrl, { 
                mode: 'cors',
                cache: 'no-cache'
            });
            
            if (!response.ok) {
                throw new Error('Fallback veri de y√ºklenemedi');
            }
            
            const csvContent = await response.text();
            await parseAndLoadCSV(csvContent, 'Fallback');
        }

        window.addEventListener('DOMContentLoaded', async () => {
            const container = document.getElementById('match-container');
            container.innerHTML = `
                <div class="premium-alert success">
                    ‚úÖ PredictAAI Geli≈ümi≈ü Analiz Motoru Hazƒ±r!<br><br>
                    <strong>üß† √áalƒ±≈üma Prensibi:</strong><br>
                    1Ô∏è‚É£ <strong>Oran Analizi (%40)</strong> - Bahis oranlarƒ±ndan olasƒ±lƒ±k hesaplama<br>
                    2Ô∏è‚É£ <strong>Form Analizi (%25)</strong> - Son 5 ma√ßƒ±n aƒüƒ±rlƒ±klƒ± deƒüerlendirmesi<br>
                    3Ô∏è‚É£ <strong>H2H Analizi (%20)</strong> - Ge√ßmi≈ü kar≈üƒ±la≈ümalar<br>
                    4Ô∏è‚É£ <strong>Ev/Deplasman (%15)</strong> - Saha avantajƒ± ve performans<br><br>
                    <strong>üìä Ek Tahminler:</strong><br>
                    ‚Ä¢ Alt/√úst 2.5 Gol (gol ortalamalarƒ± dahil)<br>
                    ‚Ä¢ Kar≈üƒ±lƒ±klƒ± Gol (BTTS)<br>
                    ‚Ä¢ Detaylƒ± olasƒ±lƒ±k daƒüƒ±lƒ±mƒ±<br><br>
                    <strong>üéØ NESƒ∞NE FORMAT DESTEƒûƒ∞ AKTƒ∞F!</strong><br><br>
                    <strong>üöÄ Ba≈ülatƒ±lƒ±yor...</strong>
                </div>
            `;
            
            await checkAPIStatus();
            
            setTimeout(() => {
                loadHistoricalData().catch(error => {
                    console.error('CSV y√ºkleme hatasƒ±:', error);
                    container.innerHTML = `
                        <div class="premium-alert warning">
                            ‚ö†Ô∏è Otomatik y√ºkleme ba≈üarƒ±sƒ±z oldu.<br><br>
                            <strong>√á√∂z√ºm se√ßenekleri:</strong><br><br>
                            <button class="premium-btn" onclick="loadHistoricalData()" style="margin: 10px 5px;">
                                üîÑ Tekrar Dene
                            </button>
                            <button class="premium-btn secondary" onclick="manualLoadCSV()" style="margin: 10px 5px;">
                                üìÇ Manuel CSV Y√ºkle
                            </button>
                            <button class="premium-btn" onclick="loadManualMatches()" style="margin: 10px 5px;">
                                üß™ Manuel Ma√ß Ekle
                            </button>
                        </div>
                    `;
                });
            }, 1000);
        });
    </script>
</body>
</html>